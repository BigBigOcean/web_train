牛客网学习笔记

下面标签嵌套正确的是
正确答案: D   你的答案: C (错误)<br>
`<ul><p>牛客网</p></ul>`<br>
`<a href="#"><a href="#">牛客网</a></a>`<br>
`<dl><li>牛客网</li></dl>`<br>
`<ol><li>牛客网</li></ol>`<br>

A.ul只能紧挨着li<br>
B.a中不能再嵌套a<br>
C.dl dt<br>
D.ol li是有序排列<br>
总结：
ul+li 是无序列表
ol+li 是有序列表
dl+dt+dd 是自定义列表

HTML5 新增的表单元素：datalist、keygen、output<br>
datalist 元素规定输入域的选项列表。 keygen 元素的作用是提供一种验证用户的可靠方法。 output 元素用于不同类型的输出<br>
其中datalist语法练习记录：<br>
姓名：<input type="text" list="name" />
		<datalist id="name">
			<option value="1">zhangsan</option>
			<option value="2">lisi</option>
		</datalist>
input里面要写list="xxx" 然后datalist里面id="xxx"才可以生效
mailto 后面加发送邮件地址<br>
a) 置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。 <br>
例如：
浏览器会根据`<img>`标签的src属性的 值来读取图片信息并显示出来，而如果查看(x)html代码，则看不到图片的实际内容。<br>
`<input>`标签的type属性来决定是显示输入框，还是单选按钮等。 <br>
html中的`<img>、<input>、<textarea>、<select>、<object>` 都是置换元素。<br>
这些元素往往没有实际的内容，即是一个空元素。置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因。<br>
b) 不可替换元素：(x)html 的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。例如标签`<label>`是一个非置换元素，文字label中的内容”将全被显示。<br>
总结：<br>
置换元素：`<img>、<input>、<textarea>、<select>、<object> `<br>


下面哪条声明能固定背景图片（）   <br>
正确答案: A   你的答案: A (正确)<br>
background-attachment:fixed;<br>
background-attachment:scroll;<br>
background-origin: initial;<br>
background-clip: initial;<br>
总结：<br>
background-attachment :定义背景图片随滚动轴的移动方式 <br>
取值: scroll | fixed | inherit <br>
scroll: 随着页面的滚动轴背景图片将移动 <br>
fixed: 随着页面的滚动轴背景图片不会移动 <br>
inherit: 继承初始值: scroll <br>

display: none和visibility:hidden的区别就是visibility:hidden会保留元素的空间<br>
repaint(重绘) ，repaint发生更改时，元素的外观被改变，且在没有改变布局的情况下发生，如改变outline,visibility,background color，不会影响到dom结构渲染。<br>
reflow(渲染)，与repaint区别就是他会影响到dom的结构渲染，同时他会触发repaint，他会改变他本身与所有父辈元素(祖先)，这种开销是非常昂贵的，导致性能下降是必然的，页面元素越多效果越明显。<br>
所以display:none才会产生reflow<br>
visibility:hidden只会触发repaint<br>
总结：<br>
display:none可以理解为看不见摸不着 <br>
visibility：hidden可以理解为看不见摸得着 <br>
display的切换会触发reflow，而visibility不会。<br>

标准盒子模型 ＝ margin + border + padding + content （content =  width | height）<br>
IE盒子模型 ＝ margin + content （content = border + padding + width | height）<br>
（width|height指的是content的宽|高）
<br>
下面哪个属性不会让 div 脱离文档流（normal flow）？<br>
正确答案: C   你的答案: C (正确)<br>
position: absolute;<br>
position: fixed;<br>
position: relative;<br>
float: left;<br>

A：position: absolute;生成绝对定位的元素，相对于static 定位以外的第一个父元素进行定位；都绝对定位了，肯定脱离了文档流。<br>
B:position: fixed;生成绝对定位的元素，相对于浏览器窗口进行定位;相对于浏览器了，也和正常顺序排下来没什么关系。<br>
C:position: relative;生成相对定位的元素，相对于其正常位置进行定位。生成相对定位，也就是说还在原本的上下左右之间，上下左右的元素都不变，so这个没有能脱离文档流。<br>
D:float: left;都浮动出去了，还上哪保持原位置去。<br>
最终答案选择C<br>

text-transform:capitalize是首字母大写<br>
text-transfrom:lowercase是全部字母为小写<br>
text-transfrom:uppercase是全部字母为大写<br>
font-weight: bold;字体为粗体，<br>
用法：`#p{text-transform:lowercase;}`<br>

假设在今日头条里面,有很多工作人员检查新闻是不是属于虚假新闻,所有新闻真实率到达了98%,工作人员在检验一个真实的新闻把它检验为一个虚假的新闻的概率为2%,而一个虚假的新闻被检验为真实的新闻的概率为5%.那么,一个被检验为真实的新闻确实是真实的新闻的概率是多大?<br>
解：<br>
假设总共100个新闻，那么真实新闻为98个，虚假新闻为2个，检验为真实的新闻 总个数为真实的检验为真实的 和虚假的检验为真实的 之和：98x(1-2%)+2x5%=96.14个，其中检验为真实的真实新闻个数即是真实的检验为真实的 个数：98x(1-2%)=96.04个，所以其真实概率为96.04/96.14=0.9989<br>

现在有两堆石子,小今与小条玩游戏,2个人都足够聪明,两个人规定:每次每人只能从其中一堆中取走1个或2个或3个石子,最后将石子全部取完的人胜利.现在两堆石子的个数为8和9,请问如何安排才能让小今必胜?<br>
解：<br>
以4为倍数，取完后两堆石头为0 0，0 4，4 4,8 4，8 8的必胜。如A取完为4 4，无论B怎么取，A都能保证为0 4，B再取，A就可以为0 0，就赢了。同理,A只要保证取完为8 8，就一定可以保证自己可以获得4 4，还可以一直往上推，12 12.....<br>


以下描述正确的：
正确答案: B C D   你的答案: A C (错误)
Http协议所使用的运输层协议是UDP
Https的端口号是443
TCP注重数据可靠性，UDP注重数据传输快
传输层提供端到端的可靠报文传递和错误恢复

总结：<br>
HTTP的端口号是80，https的端口号是443，两者不能混淆了。<br>

OSI七层模型
7 应用层：允许访问网络资源。 通信单位：报文（指的是TCP/IP协议里广义的应用层 ） 
6 表示层：数据的转换，加密，压缩  
5 会话层：建立，管理，终止会话  
4 运输层：提供可靠的进程到进程的交付和差错恢复。  
3 网络层：从源到终点传送分组，提供网络互联。通信单位 数据报 
2 数据链路层：将比特组织成帧结构，提供逐跳交付。通信单位 帧 
1 物理层：经过媒体传送比特

TCP与UDP<br>
UDP（ User Datagram Protocal， 用户数据报协议 ）<br>
（1）简介<br>
面向数据报的不可靠的 传输层通信协议<br>
（2）特点<br>
UDP不能保证可靠传输，也就更不能保证所发送的数据的到达顺序，它所实现的是尽最大的努力交付。<br>
UDP是面向数据报文的、无连接的协议，因此它的开销低并且发送器前的时延小（因为不用建立连接啊），面向报文也使得IP层在传输UDP协议的报文时既不会拆分也不会合并。<br>
UDP可以支持一对一、一对多、多对一、多对多的通信。<br>
UDP没有拥塞控制功能，它的发送速率不会随着网络出现的拥塞而降低，所以它的实时性较好。这也是许多视频聊天应用采用它的原因。<br>
（3）报文格式<br>
<br>
TCP（ Transmission Control Protocol， 传输控制协议  ）<br>
（1）简介<br>
面向连接的、可靠的、基于字节流的传输层通信协议<br>
（2）特点<br>
TCP协议保证可靠传输，也就是说发送的数据是什么样，接收的数据也是什么样。<br>
TCP协议是有连接的、面向数据流的协议。有连接是说数据传送前通信双方需要建立连接、通信完毕后需要断开连接，不过这里所提到的连接都是逻辑上的连接。面向数据流的意思是说发送方应用程序发送的数据是什么顺序，接收方应用读取的接收到的数据也是什么顺序。<br>
TCP协议提供的是端到端的通信，也就是说一条TCP连接只能提供一对一的通信。不过，一个应用可以同时建立多条TCP连接来实现与多个目标的通信。<br>
TCP协议提供拥塞控制功能，会在网络状况良好的情况下适当提高发送/接收速率，反之则适当降低发送/接收速率。这样，将会提高对网络的利用率。<br>
（3） 数据封包结构<br>
<br>
SQL提供了四种匹配模式：<br>
1. % 表示任意0个或多个字符。如下语句：Select * FROM user Where name LIKE '%三%'; 将会把name为“张三”，“三脚猫”，“唐三藏”等等有“三”的全找出来。%三：表示左匹配。三%：表示右匹配。%三%：表示模糊查询。<br>
2. _ 表示任意单个字符。语句： Select * FROM user Where name LIKE '_三_'；只找出“唐三藏”。这样name为三个字且中间一个字是“三”的； Select * FROM user Where name LIKE '三__'； 只找出“三脚猫”这样name为三个字且第一个字是“三”的；<br>
3. [ ] 表示括号内所列字符中的一个（类似与正则表达式）。语句：Select * FROM user Where name LIKE '[张李王]三'; 将找出“张三”、“李三”、“王三”（而不是“张李王三”）； 如 [ ] 内有一系列字符（01234、abcde之类的）则可略写为“0-4”、“a-e“。Sele<br>ct * FROM user Where name LIKE '老[1-9]'；将找出“老1”、“老2”、……、“老9”；如要找“-”字符请将其放在首位：'张三[-1-9]'；<br>
4. [^ ] 表示不在括号所列之内的单个字符。语句：Select * FROM user Where name LIKE '[^张李王]三'；将找出不姓“张”、“李”、“王”的“赵三”、“孙三”等；Select * FROM user Where name LIKE '老[^1-4]'; 将排除“老1”到“老4”寻找“老5”、“老6”、……、“老9”。<br>
5.* 表示查找的是所有信息,例如select * from tbl_user<br>

“进程是资源分配的最小单位，线程是CPU调度的最小单位”。<br>

LRU全称是Least Recently Used，即最近最久未使用的意思。 下面说一下LRU算法的核心思想，LRU算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。<br>
FIFO（First in First out），先进先出。在FIFO Cache设计中，核心原则就是： 如果一个数据最先进入缓存中，则应该最早淘汰掉 。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。<br>
LFU（Least Frequently Used）最近最少使用算法。它是基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。
注意：<br>
1.LFU和LRU算法的不同之处，LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的。<br>
2.FIFO算法会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常。<br>

算法稳定性：
1)冒泡排序

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

(2)选择排序

选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

(3)插入排序 
插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。

(4)快速排序 
快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j，交换a[i]和a[j],重复上面的过程，直到i > j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。
https://blog.csdn.net/adusts/article/details/80882649

(5)归并排序 
归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。

(6)基数排序 
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。

(7)希尔排序(shell) 
希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

(8)堆排序 
我们知道堆的结构是节点i的孩子为2 * i和2 * i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， ... 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。（一般升序采用大顶堆，降序采用小顶堆)
https://www.cnblogs.com/chengxiao/p/6129630.html

综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法
即：
不稳定：快选堆希
稳  定：插冒归基

给定一个Excel表格中的列名称，返回其相应的列序号。<br>
解题思路：<br>
相当于26进制转化成十进制，类似于二进制与十进制之间的转换<br>

AC代码：<br>
JAVA：<br>
class Solution {<br>
public:<br>
    int titleToNumber(string s) {<br>
        int result = 0;<br>
        for(int i = 0; i < s.length(); i++)<br>
        {<br>
            result = result * 26 + (s[i] - 'A' + 1);<br>
        }<br>
        return result;<br>
    }<br>
    <br>
PYTHON：<br>
result = 0<br>
s='BA'<br>
for i in range(len(s)):<br>
    result = result * 26 + (ord(s[i]) - ord('A') + 1);<br>
print (result)<br>
<br>
运行以下程序<br>
    var m= 1, j = k = 0; <br>
    function add(n) { <br>
        return n = n+1; <br>
　 } <br>
    y = add(m); <br>
    function add(n) { <br>
        return n = n + 3; <br>
    } <br>
z = add(m); <br>
y和z的最终结果为:4,4<br>
<br>
js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数。<br>
在js中，定义了两个同名函数后，后面的函数会覆盖前面定义的函数。<br>
由于存在同名函数，后面的add函数将覆盖第一个add函数，所以两次调用add()返回的值是相同的。<br>
也就是y,z都为4.<br>

(function() {<br>
      var a = b = 5;<br>
  })();   <br>
console.log(b);<br>
console.log(a);<br>
上面的输出结果:<br>
5，Uncaught ReferenceError: a is not defined<br>
解：<br>
第一个考点在于var a=b=5相当于拆解成 b=5; var a=b；<br>
然后，b=5前面没有var，相当于声明为全局变量（这种方式在严格模式下会报错，此题不考虑)。<br>
所以就相当于： var b; (fun…{ var a=b; b=5; })();<br>
console.log(b); //5 <br>
console.log(a); //报错 <br>
此处报错也就是另一个考点，a声明的是函数的局部变量，在函数结束是就销毁了，所以在全局下找不到a，于是报错。<br>



